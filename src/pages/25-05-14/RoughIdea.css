import React, { useEffect } from "react";
import fontFile_2025_11_01 from "./dotted.ttf"; // local font (same folder)

/**
 * Vite + React component (single-file .jsx)
 * - All styles are injected inline (no external CSS, no Tailwind)
 * - Uses vh/vw/rem units (no px)
 * - @font-face injected dynamically and scoped to this component to avoid style leakage
 * - Font import variable name includes today's date (2025_11_01)
 */

export default function Clock() {
  useEffect(() => {
    const SCOPE_ID = "ri-clock-2025-11-01"; // scope to avoid leakage
    const fontName = "DottedRough2025_11_01";

    // Inject scoped <style> with @font-face and component CSS (uses vh/vw/rem only)
    const style = document.createElement("style");
    style.setAttribute("data-scope", SCOPE_ID);
    style.textContent = `
      /* Font (uses imported font file variable) */
      @font-face {
        font-family: '${fontName}';
        src: url('${fontFile_2025_11_01}') format('truetype');
        font-display: swap;
      }

      /* Scoped container so styles don't leak */
      #${SCOPE_ID} {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background-image: linear-gradient(180deg, rgb(21 84 89) 0%, rgb(228 207 249) 100%);
        position: relative;
        font-family: '${fontName}', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      }

      /* digits are absolutely positioned and animated; no px usage */
      #${SCOPE_ID} .digit {
        position: absolute;
        left: 0;
        top: 0;
        will-change: transform, opacity;
        pointer-events: none;
        white-space: pre;
        font-size: var(--digit-fs, 8vh); /* fallback via CSS var in vh */
        transform-origin: center center;
        transform-style: preserve-3d;
        animation: ri-fly-up var(--anim-duration, 12s) cubic-bezier(.2,.9,.3,1) forwards;
      }

      /* keyframes use CSS variables (values will be vw/vh strings) */
      @keyframes ri-fly-up {
        0% {
          transform:
            translate(var(--x-start), var(--y-start))
            rotateX(var(--rotate-x-start))
            rotateY(var(--rotate-y-start))
            rotateZ(var(--rotate-z-start))
            scale(var(--scale));
          opacity: 1;
        }
        15%, 90% {
          transform:
            translate(var(--x-final), var(--y-final))
            rotateZ(var(--rotate-z-final))
            scale(var(--scale));
          opacity: 1;
        }
        100% {
          transform:
            translate(var(--x-final), var(--y-final))
            rotateZ(var(--rotate-z-final))
            scale(var(--scale));
          opacity: 0;
        }
      }

      /* visually hide the screen reader time but keep it accessible */
      #${SCOPE_ID} #screen-reader-time {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
      }
    `;
    document.head.appendChild(style);

    /* ---------------------------
       Clock + animation logic
       --------------------------- */
    const root = document.getElementById(SCOPE_ID);
    const srTime = document.getElementById("screen-reader-time");

    function getTimeDigits() {
      const now = new Date();
      const hours = now.getHours() % 12 || 12;
      const minutes = String(now.getMinutes()).padStart(2, "0");
      srTime && (srTime.textContent = now.toLocaleTimeString());
      return [...(String(hours) + minutes)];
    }

    // Random helpers â€” return values using vh/vw units (no px)
    function randomColor() {
      // subtle HSL range like original but limited hue band
      return `hsl(${Math.floor(Math.random() * 21)}, 60%, 60%)`;
    }

    function randomFontSizeVH() {
      // returns between 6vh and 18vh
      const v = (Math.random() * 12 + 6).toFixed(2);
      return `${v}vh`;
    }

    function randomScale() {
      return (Math.random() * 0.5 + 0.75).toFixed(2);
    }

    function randomDirectionOffset() {
      const side = ["top", "bottom", "left", "right"][Math.floor(Math.random() * 4)];
      const vw = 100; // we'll emit vw values as strings
      const vh = 100; // vh values as strings
      switch (side) {
        case "top":
          return { x: `${(Math.random() * vw).toFixed(2)}vw`, y: `-10vh` };
        case "bottom":
          return { x: `${(Math.random() * vw).toFixed(2)}vw`, y: `110vh` };
        case "left":
          return { x: `-10vw`, y: `${(Math.random() * vh).toFixed(2)}vh` };
        case "right":
          return { x: `110vw`, y: `${(Math.random() * vh).toFixed(2)}vh` };
        default:
          return { x: "0vw", y: "0vh" };
      }
    }

    function randomRotation() {
      return `${Math.floor(Math.random() * 720 - 360)}deg`;
    }

    function randomFinalAngle() {
      return `${Math.floor(Math.random() * 31 - 15)}deg`;
    }

    function throwDigitsUp() {
      const digits = getTimeDigits();
      if (!root) return;
      const fragment = document.createDocumentFragment();

      // spacing as vw fraction so no px used
      const spacingVW = 100 / (digits.length + 1); // e.g., 100vw / (n+1)
      const centerY = 30; // 30vh final vertical placement

      digits.forEach((char, index) => {
        const span = document.createElement("span");
        span.className = "digit";
        span.textContent = char;

        // final positions in vw/vh units
        const xFinal = `${(spacingVW * (index + 1)).toFixed(4)}vw`;
        const yFinal = `${centerY}vh`;

        const scale = randomScale();
        const { x: xStart, y: yStart } = randomDirectionOffset();

        // safe inline style defaults (all units are vw/vh/rem)
        span.style.setProperty("--x-start", xStart);
        span.style.setProperty("--y-start", yStart);
        span.style.setProperty("--x-final", xFinal);
        span.style.setProperty("--y-final", yFinal);
        span.style.setProperty("--scale", scale);
        span.style.setProperty("--rotate-x-start", randomRotation());
        span.style.setProperty("--rotate-y-start", randomRotation());
        span.style.setProperty("--rotate-z-start", randomRotation());
        span.style.setProperty("--rotate-z-final", randomFinalAngle());
        span.style.setProperty("--digit-fs", randomFontSizeVH());
        // Slight variation in animation duration (controlled through CSS var)
        span.style.setProperty("--anim-duration", `${(10 + Math.random() * 8).toFixed(2)}s`);
        span.style.color = randomColor();

        // cleanup after animation
        span.addEventListener("animationend", () => {
          span.remove();
        });

        fragment.appendChild(span);
      });

      root.appendChild(fragment);
    }

    // Initially throw and then every second update (so digits represent current time)
    throwDigitsUp();
    const interval = setInterval(throwDigitsUp, 1000);

    // clean-up on unmount: remove style and clear interval and all child digits
    return () => {
      clearInterval(interval);
      style.remove();
      // remove any remaining digits appended to this component
      const existing = document.querySelectorAll(`#${SCOPE_ID} .digit`);
      existing.forEach((n) => n.remove());
    };
  }, []); // run once on mount

  // Render: root element id matches SCOPE_ID used in effect
  return (
    <div id="ri-clock-2025-11-01" role="application" aria-label="Animated clock">
      <time id="screen-reader-time" aria-live="polite" />
    </div>
  );
}
