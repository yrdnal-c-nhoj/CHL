import React,{useState,useEffect,useRef}from "react"; export default function ChaoticClock({accentColor = "#ff6600"}){const extraHandsRef = useRef([]);const [time,setTime] = useState(0);const [secondHandPositions,setSecondHandPositions] = useState(() => Array.from({length: 125}).map(() => ({offsetX: (Math.random() - .5) * 1.6,offsetY: (Math.random() - .5) * 1.6,})));// Main clock hands refs const hourRefs = useRef(Array(25).fill(null));const minuteRefs = useRef(Array(25).fill(null));const secondRefs = useRef(Array(125).fill(null));// Random positions for hour and minute hands (generated once) const [mainHandsPositions] = useState(() => Array.from({length: 25}).map(() => ({offsetX: (Math.random() - .5) * 1.6,offsetY: (Math.random() - .5) * 1.6,})));// 25 chaotic jagged hand configs with right-angle preference const [extraSecondsConfig] = useState(() => Array.from({length: 25}).map(() => ({startX: (Math.random() - .5) * 1.6,startY: (Math.random() - .5) * 1.6,segmentCount: Math.floor(Math.random() * 10) + 8,maxSegmentLength: .05 + Math.random() * .15,strokeWidth: .5 + Math.random() * 1.5,baseColor: accentColor,phaseShift: Math.random() * Math.PI * 2,baseAngle: Math.random() * Math.PI * 2,spinSpeed: (Math.random() - .5) * .5,fadeSpeed: .5 + Math.random() * 1.5,fadePhase: Math.random() * Math.PI * 2,})));// Animation loop useEffect(() => {let animationFrame; const tick = () => {setTime(performance.now() / 1000); animationFrame = requestAnimationFrame(tick);}; tick(); return () => cancelAnimationFrame(animationFrame);},[]);// Update second hand positions every second useEffect(() => {const interval = setInterval(() => {setSecondHandPositions(Array.from({length: 125}).map(() => ({offsetX: (Math.random() - .5) * 1.6,offsetY: (Math.random() - .5) * 1.6,})));},1000); // Update every 1 second return () => clearInterval(interval);},[]);// Update all hands useEffect(() => {const now = new Date(); const sec = now.getSeconds() + now.getMilliseconds() / 1000; const min = now.getMinutes() + sec / 60; const hr = now.getHours() % 12 + min / 60; const radH = (Math.PI * 2 * (hr / 12)) - Math.PI / 2; const radM = (Math.PI * 2 * (min / 60)) - Math.PI / 2; const radS = (Math.PI * 2 * (sec / 60)) - Math.PI / 2; // Update hour and minute hands at fixed random positions mainHandsPositions.forEach((pos,idx) => {if (hourRefs.current[idx]) {hourRefs.current[idx].setAttribute("transform",`translate(${pos.offsetX},${pos.offsetY}) rotate(${(radH * 180) / Math.PI})`);} if (minuteRefs.current[idx]) {minuteRefs.current[idx].setAttribute("transform",`translate(${pos.offsetX},${pos.offsetY}) rotate(${(radM * 180) / Math.PI})`);}}); // Update second hands at dynamic random positions with time-based rotation secondHandPositions.forEach((pos,idx) => {if (secondRefs.current[idx]) {secondRefs.current[idx].setAttribute("transform",`translate(${pos.offsetX},${pos.offsetY}) rotate(${(radS * 180) / Math.PI})`);}}); // Update chaotic hands with right-angle paths extraSecondsConfig.forEach((config,i) => {const currentAngle = config.baseAngle + time * config.spinSpeed; const pathPoints = []; let x = config.startX; let y = config.startY; // Restrict angles to 0째,90째,180째,270째 const angles = [0,Math.PI / 2,Math.PI,(3 * Math.PI) / 2]; for (let j = 0; j < config.segmentCount; j++) {const segLength = config.maxSegmentLength * (.5 + .5 * Math.sin(time * 2 + j + config.phaseShift)); const angle = angles[Math.floor(Math.random() * 4)]; x += Math.cos(angle) * segLength; y += Math.sin(angle) * segLength; pathPoints.push([x,y]);} const opacity = .3 + .7 * Math.abs(Math.sin(time * config.fadeSpeed + config.fadePhase)); extraHandsRef.current[i] = {d: `M ${config.startX} ${config.startY} L ${pathPoints.map((p) => p.join(" ")).join(" L ")}`,stroke: config.baseColor,strokeWidth: config.strokeWidth,opacity,};});},[time,extraSecondsConfig,mainHandsPositions,secondHandPositions]);return (<svg viewBox="-2 -2 4 4" style={{width: "400px",height: "400px",background: "#111",borderRadius: "50%"}}> {} <circle cx="0" cy="0" r="1.98" stroke="#888" strokeWidth="0.02" fill="none" /> {} {extraHandsRef.current.map((hand,idx) => (<path key={`extra-${idx}`} {...hand} fill="none" />))} {} {mainHandsPositions.map((_,idx) => (<g key={`main-${idx}`}> {} <path ref={(el) => (hourRefs.current[idx] = el)} d={`M 0 0 L .3 0 L .3 -.15`} stroke="#888fff" strokeWidth="0.05" fill="none" /> {} <path ref={(el) => (minuteRefs.current[idx] = el)} d={`M 0 0 L .45 0 L .45 -.1`} stroke="#fff" strokeWidth="0.03" fill="none" /> </g>))} {} {secondHandPositions.map((_,idx) => (<g key={`second-${idx}`}> <path ref={(el) => (secondRefs.current[idx] = el)} d={`M 0 0 L .5 0 L .5 -.05`} stroke={accentColor} strokeWidth="0.015" // Reduced stroke width for clarity fill="none" opacity={.6 + .4 * Math.sin((idx + time) * Math.PI)} // Subtle opacity variation /> </g>))} </svg>)}
